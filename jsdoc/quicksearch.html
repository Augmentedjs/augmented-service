<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"service.js.html":{"id":"service.js.html","title":"Source: service.js","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Source: service.js /** * service.js - The Service Core Component&lt;br/&gt; * The &lt;b&gt;Service&lt;/b&gt; extension adds extensive abilities to the service (Node.js) layer.&lt;br/&gt; * This extension adds:&lt;br/&gt; * &lt;ul&gt; * &lt;li&gt;DataSource&lt;/li&gt; * &lt;li&gt;Entity&lt;/li&gt; * &lt;li&gt;Resource&lt;/li&gt; * &lt;/ul&gt; * * @author Bob Warren * * @requires augmentedjs (&quot;augmentedjs&quot; in npm) * @requires node * @requires http * @module Augmented.Service * @version 1.3.2 * @license Apache-2.0 */ (function(moduleFactory) { if (typeof exports === &quot;object&quot;) { module.exports = moduleFactory(require(&quot;augmentedjs&quot;)); } // AMD and Browser not supported, only Node /*else if (typeof define === &quot;function&quot; &amp;&amp; define.amd) { define([&quot;augmented&quot;], moduleFactory); } else { window.Augmented.Service = moduleFactory(window.Augmented.Service); }*/ }(function(Augmented) { &quot;use strict&quot;; var http = require(&quot;http&quot;); /** * The base namespece for all of the Service module. * @namespace Service * @memberof Augmented */ Augmented.Service = {}; /** * The standard version property * @constant VERSION * @memberof Augmented.Service */ Augmented.Service.VERSION = &quot;1.3.2&quot;; /** * A nice console logger with prefix for service messages * @class Logger * @memberof Augmented.Service */ Augmented.Service.Logger = { _logger: null, _prefix: &quot;SERVICE&quot;, /** * Set the prefix of the logger * @method setPrefix * @param {string} prefix The prefix for the logger message * @memberof Augmented.Service.Logger */ setPrefix: function(prefix) { this._prefix = prefix; }, log: function(message) { this._logger.log(this._prefix + &quot;: &quot; + message); }, info: function(message) { this._logger.info(this._prefix + &quot;: &quot; + message); }, debug: function(message) { this._logger.debug(this._prefix + &quot;: &quot; + message); }, warn: function(message) { this._logger.warn(this._prefix + &quot;: &quot; + message); }, error: function(message) { this._logger.error(this._prefix + &quot;: &quot; + message); }, /** * Get an instance class of the service color logger * @method getServiceLogger * @param {Augmented.Logger.Level} level The logger level * @param {string} prefix Optional prefix for the logger message * @memberof Augmented.Service.Logger */ getLogger: function(level, prefix) { if (!level) { level = Augmented.Logger.Level.info; } this._logger = Augmented.Logger.LoggerFactory.getLogger( Augmented.Logger.Type.colorConsole, level); if (prefix) { this.setPrefix(prefix); } return this; } }; /** * A private logger for use in the framework only * @private */ const logger = Augmented.Service.Logger.getLogger(Augmented.Configuration.LoggerLevel, &quot;SERVICE&quot;); /** * The datasource object for use as an interface for a datasource * @interface DataSource * @memberof Augmented.Service */ Augmented.Service.DataSource = function(client) { this.connected = false; this.style = &quot;database&quot;; /** * @property {object} client The client for use in the DataSource * @memberof Augmented.Service.DataSource */ this.client = (client) ? client : null; /** * @property {string} url The url for the datasource (if applicable) * @memberof Augmented.Service.DataSource */ this.url = &quot;&quot;; /** * @property {object} db The database (or simular) for the datasource (if applicable) * @memberof Augmented.Service.DataSource */ this.db = null; /** * @property {object} collection The collection for use in the DataSource * @memberof Augmented.Service.DataSource */ this.collection = null; /** * @method getConnection Get a connection to the DataSource * @memberof Augmented.Service.DataSource * @returns {boolean} Returns true if a connection is established */ this.getConnection = function() { return false; }; /** * @method closeConnection Close a connection to the DataSource (depending on type may not be needed) * @memberof Augmented.Service.DataSource * @returns {boolean} Returns true if a connection is established */ this.closeConnection = function() {}; /** * @method insert Insert data * @memberof Augmented.Service.DataSource * @param {object} data Data to insert */ this.insert = function(data) {}; /** * @method remove Remove data * @memberof Augmented.Service.DataSource * @param {object} data Data to remove */ this.remove = function(data) {}; /** * @method update Update data * @memberof Augmented.Service.DataSource * @param {object} data Data to update */ this.update = function(data) {}; /** * @method query Query data * @memberof Augmented.Service.DataSource * @param {object} query The query object * @param {function} callback A callback to execute during the query * @returns {object} Returns a value from the query or response code */ this.query = function(query, callback) { return null; }; /** * @method getCollection Get the collection * @memberof Augmented.Service.DataSource * @returns {object} Returns the collection */ this.getCollection = function() { return this.collection; }; /** * @method setCollection Set the collection by name * @memberof Augmented.Service.DataSource * @param {string} name The name of the collection */ this.setCollection = function(name) { }; }; Augmented.Service.MemoryDataSource = function(client) { Augmented.Service.DataSource.call(this, client); this.style = &quot;array&quot;; this.db = []; this.getConnection = function(url, collection) { this.connected = true; if (collection) { this.collection = collection; } this.url = url; this.style = &quot;array&quot;; return true; }; this.closeConnection = function() { if (this.db &amp;&amp; this.connected) { this.connected = false; this.db = null; this.collection = null; } }; this.insert = function(data) { this.db.push(data); }; } /** * The MongoDB datasource instance class * @constructor MongoDataSource * @implements {Augmented.Service.DataSource} * @augments Augmented.Service.DataSource * @memberof Augmented.Service */ Augmented.Service.MongoDataSource = function(client) { Augmented.Service.DataSource.call(this, client); this.setCollection = function(name) { logger.debug(&quot;setCollection: &quot; + name); if (name &amp;&amp; Augmented.isString(name)) { logger.debug(&quot;collection: &quot; + name); this.collection = this.db.collection(name); } else { logger.debug(&quot;no collection set&quot;); } }; this.getConnection = function(url, collection) { this.connected = false; var that = this; if (this.client &amp;&amp; !this.connected) { this.client.connect(url, function(err, db) { if(!err) { if (collection) { logger.debug(&quot;getConnection: collection: &quot; + collection); that.collection = db.collection(collection); } else { logger.debug(&quot;getConnection: no collection&quot;); } that.db = db; that.url = url; that.connected = true; that.style = &quot;database&quot;; } else { logger.error(err); throw new Error(err); } }); return true; } else { logger.error(&quot;no client was passed.&quot;); } return false; }; this.closeConnection = function() { if (this.db &amp;&amp; this.connected) { this.db.close(); this.connected = false; this.db = null; this.collection = null; } }; this.query = function(query, callback) { var ret = {}; if (this.collection &amp;&amp; this.connected) { logger.debug(&quot;The query: &quot; + query); const myQuery = query; if (Augmented.isFunction(query)) { myQuery = query(); } this.collection.find(myQuery).toArray(function(err, results) { if(!err) { logger.debug(&quot;Results: &quot; + JSON.stringify(results)); if (results) { ret = results; } if (callback) { callback(ret); } else { logger.debug(&quot;MongoDatasource, no callback&quot;); } } else { logger.error(err); throw new Error(err); } }); } else { logger.error(&quot;no collection defined or not connected to db.&quot;); } logger.debug(&quot;ret: &quot; + JSON.stringify(ret)); return ret; }; this.insert = function(data, callback) { var ret = {}; if (this.collection &amp;&amp; this.connected) { if (Array.isArray(data)) { this.collection.insertMany(data, function(err, result) { if(!err) { logger.debug(&quot;Result: &quot; + JSON.stringify(result)); if (result) { ret = result; if (callback) { callback(ret); } } } else { logger.error(err); throw new Error(err); } }); } else { this.collection.insertOne(data, function(err, result) { if(!err) { logger.debug(&quot;Result: &quot; + JSON.stringify(result)); if (result) { ret = result; if (callback) { callback(ret); } } } else { logger.error(err); throw new Error(err); } }); } } else { logger.error(&quot;no collection defined or not connected to db.&quot;); } logger.debug(&quot;ret: &quot; + JSON.stringify(ret)); return ret; }; this.update = function(query, data, callback) { if (this.collection &amp;&amp; this.connected) { logger.debug(&quot;The query: &quot; + query); const myQuery = query; if (Augmented.isFunction(query)) { myQuery = query(); } this.collection.update(myQuery, data, function(err, result) { if(!err) { logger.debug(&quot;Result: &quot; + JSON.stringify(result)); } else { logger.error(err); throw new Error(err); } }); if (callback) { callback(data); } } else { logger.error(&quot;no collection defined or not connected to db.&quot;); } return data; }; this.remove = function(query, callback) { var ret = {}; if (this.collection &amp;&amp; this.connected) { logger.debug(&quot;The query: &quot; + query); const myQuery = query; if (Augmented.isFunction(query)) { myQuery = query(); } this.collection.remove(myQuery, function(err, results) { if(!err) { if (callback) { callback(); } } else { logger.error(err); throw new Error(err); } }); } else { logger.error(&quot;no collection defined or not connected to db.&quot;); } return ret; }; }; Augmented.Service.MongoDataSource.prototype = Object.create(Augmented.Service.DataSource.prototype); Augmented.Service.MongoDataSource.prototype.constructor = Augmented.Service.MongoDataSource; /** * The SOLR datasource instance class * @constructor SOLRDataSource * @implements {Augmented.Service.DataSource} * @augments Augmented.Service.DataSource * @memberof Augmented.Service */ Augmented.Service.SOLRDataSource = function(client) { Augmented.Service.DataSource.call(client, this,arguments); this.getConnection = function(url, collection) { this.connected = false; var that = this; if (this.client &amp;&amp; !this.connected) { this.client.ping(function(err, db){ if(!err) { logger.debug(&quot;collection: &quot; + collection); that.collection = collection; that.db = db; that.url = url; that.connected = true; that.style = &quot;search&quot;; } else { logger.error(err); throw new Error(err); } }); } else { logger.error(&quot;no client was passed.&quot;); } return this.connected; }; this.closeConnection = function() { if (this.db &amp;&amp; this.connected) { this.connected = false; this.db = null; this.collection = null; } }; this.query = function(query, callback) { var ret = {}; return ret; }; this.insert = function(data, callback) { var ret = {}; return ret; }; this.update = function(query, data, callback) { return data; }; this.remove = function(query, callback) { var ret = {}; return ret; }; }; Augmented.Service.SOLRDataSource.prototype = Object.create(Augmented.Service.DataSource.prototype); Augmented.Service.SOLRDataSource.prototype.constructor = Augmented.Service.SOLRDataSource; /** * The datasource factory to return an instance of a datasource configured by type * @namespace DataSourceFactory * @memberof Augmented.Service */ Augmented.Service.DataSourceFactory = { Type: { &quot;Memory&quot;: &quot;memory&quot;, &quot;MongoDB&quot;: &quot;mongodb&quot;, &quot;SOLR&quot;: &quot;solr&quot; }, getDatasource: function(type, client) { if (type === &quot;mongodb&quot;) { return new Augmented.Service.MongoDataSource(client); } else if (type === &quot;solr&quot;) { return new Augmented.Service.SOLRDataSource(client); } else if (type === &quot;memory&quot;) { return new Augmented.Service.MemoryDataSource(client); } return null; } }; /** * Collection class to handle REST&lt;/br/&gt; * * @constructor Augmented.Service.ResourceCollection * @memberof Augmented.Service */ Augmented.Service.ResourceCollection = Augmented.Collection.extend({ /** * Collection name for us in a datasource or an identifier * @property {string} name The name of the collection * @memberof Augmented.Service.ResourceCollection */ name: &quot;collection&quot;, /** * @property {string} url The url for the datasource (if applicable) * @memberof Augmented.Service.ResourceCollection */ url: &quot;&quot;, /** * @method setURL Set the url for the ResourceCollection * @param {string|function} url The URL or a function to retun a URL object * @memberof Augmented.Service.ResourceCollection */ setURL: function(url) { this.url = url; }, }); /** * Collection class to handle ORM to a datasource&lt;/br/&gt; * &lt;em&gt;Note: Datasource property is required&lt;/em&gt; * * @constructor Augmented.Service.EntityCollection * @memberof Augmented.Service */ Augmented.Service.Collection = Augmented.Service.EntityCollection = Augmented.Collection.extend({ /** * Collection name for us in a datasource or an identifier * @property {string} name The name of the collection * @memberof Augmented.Service.EntityCollection */ name: &quot;collection&quot;, /** * The query to use for the query - defaults to &quot;id&quot; selection * @method {any} query The query string to use for selection * @memberof Augmented.Service.EntityCollection */ query: null, /** * @property {string} url The url for the datasource (if applicable) * @memberof Augmented.Service.EntityCollection */ url: &quot;&quot;, /** * @method initialize Initialize the model with needed wireing * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ initialize: function(options) { if (options) { logger.debug(&quot;calling initialize with options: &quot; + JSON.stringify(options)); if (options.datasource) { this.datasource = options.datasource; } if (options.query) { this.query = options.query; } if (options.name) { this.name = options.name; } if (options.url) { this.url = options.url; } } if (this.datasource &amp;&amp; (this.url === &quot;&quot;)) { this.url = this.datasource.url; } this.setDataSourceCollection(this.name); this.init(options); }, /** * @method init Custom init method for the model (called at initialize) * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ init: function(options) {}, /** * @property {Augmented.Service.DataSource} datasource Datasource instance * @memberof Augmented.Service.EntityCollection */ datasource: null, /** * @method setDatasource Set the datasource for the Collection * @param {object} datasource The datasource object * @memberof Augmented.Service.EntityCollection */ setDatasource: function(datasource) { this.datasource = datasource; }, /** * @method sync Sync method to handle datasource functions for the Collection * @param {string} method the operation to perform * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ sync: function(method, options) { logger.debug(&quot;sync &quot; + method); if (this.datasource) { var that = this; try { var j = {}, q; if (method === &quot;create&quot;) { j = this.toJSON(); this.datasource.insert(j, function() { that.reset(j); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else if (method === &quot;update&quot;) { j = this.toJSON(); if (options &amp;&amp; options.query) { q = options.query; } else { q = this.query; } this.datasource.update(q, j, function() { //that.reset(j); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else if (method === &quot;delete&quot;) { if (options &amp;&amp; options.query) { q = options.query; } else { q = this.query; } this.datasource.remove(q, function() { that.reset(); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else { // read logger.log(&quot;reading&quot;); if (options &amp;&amp; options.query) { q = options.query; } else { q = this.query; } logger.debug(&quot;query &quot; + JSON.stringify(q)); this.datasource.query(q, function(data) { that.reset(data); logger.debug(&quot;returned: &quot; + JSON.stringify(data)); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(data); } }); } } catch(e) { if (options &amp;&amp; options.error &amp;&amp; (typeof options.error === &quot;function&quot;)) { options.error(e); } //throw(e); } } else { logger.warn(&quot;no datasource&quot;); } return {}; }, /** * @method fetch Fetch the entity * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ fetch: function(options) { this.sync(&quot;read&quot;, options); }, /** * @method save Save the entity * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ save: function(options) { this.sync(&quot;create&quot;, options); }, /** * @method update Update the entity * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ update: function(options) { this.sync(&quot;update&quot;, options); }, /** * @method destroy Destroy the entity * @param {object} options Any options to pass * @memberof Augmented.Service.EntityCollection */ destroy: function(options) { this.sync(&quot;delete&quot;, options); }, setDataSourceCollection: function(name) { if (name &amp;&amp; Augmented.isString(name) &amp;&amp; this.datasource) { logger.debug(&quot;service: setting collection name: &quot; + name); this.name = name; this.datasource.setCollection(name); } } }); /** * Entity class to handle ORM to a datasource&lt;/br/&gt; * &lt;em&gt;Note: Datasource property is required&lt;/em&gt; * * @constructor Augmented.Service.Entity * @extends Augmented.Model * @memberof Augmented.Service */ Augmented.Service.Entity = Augmented.Model.extend({ id: &quot;&quot;, /** * The query to use for the query - defaults to &quot;id&quot; selection * @method {any} query The query string to use for selection * @memberof Augmented.Service.Entity */ query: {}, /** * @property {string|function} url The url for the datasource (if applicable) * @memberof Augmented.Service.Entity */ url: &quot;&quot;, /** * @property {string} collection The collection for the datasource (if applicable) * @memberof Augmented.Service.Entity */ collection: &quot;collection&quot;, /** * @method initialize Initialize the model with needed wireing * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ initialize: function(options) { if (options) { if (options.collection) { this.collection = options.collection; } if (options.datasource) { this.datasource = options.datasource; } if (options.url) { this.url = this.datasource.url; } if (options.id) { this.id = options.id; } if (options.query) { this.query = options.query; } } // don't save this as data, but properties via the object base class options copy. this.unset(&quot;datasource&quot;); this.unset(&quot;url&quot;); this.unset(&quot;query&quot;); this.unset(&quot;collection&quot;); this.unset(&quot;id&quot;); if (this.datasource) { this.datasource.setCollection(this.collection); } this.init(options); }, /** * @method init Custom init method for the model (called at inititlize) * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ init: function(options) {}, /** * @property {Augmented.Service.DataSource} datasource Datasource instance * @memberof Augmented.Service.Entity */ datasource: null, /** * @method sync Sync method to handle datasource functions for the model * @param {string} method the operation to perform * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ sync: function(method, options) { logger.debug(&quot;sync &quot; + method); if (this.datasource) { var that = this; try { var j = {}, q; if (method === &quot;create&quot;) { j = that.attributes; this.datasource.insert(j, function() { that.reset(j); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else if (method === &quot;update&quot;) { j = that.attributes; //logger.debug(&quot;The object: &quot; + JSON.stringify(j)); if (options &amp;&amp; options.query) { q = options.query; } else { q = this.query; } this.datasource.update(q, j, function() { //that.reset(j); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else if (method === &quot;delete&quot;) { if (options &amp;&amp; options.query) { q = options.query; } else { q = this.query; } this.datasource.remove(q, function() { that.reset(); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(); } }); } else { // read logger.debug(&quot;reading&quot;); if (options &amp;&amp; options.query) { q = options.query; } else { q = that.query; } var myQuery = q; if (Augmented.isFunction(q)) { var x = q(); logger.debug(&quot;x &quot; + x); myQuery = x; } logger.debug(&quot;query &quot; + JSON.stringify(myQuery)); this.datasource.query(myQuery, function(data) { if (data === null) { throw new Error(&quot;No Data Returned!&quot;); } if (Array.isArray(data) &amp;&amp; data.length &gt; 0) { that.reset(data[0]); } else if (Array.isArray(data) &amp;&amp; data.length === 0) { that.reset(); } else { that.reset(data); } logger.debug(&quot;returned: &quot; + JSON.stringify(data)); if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { options.success(data); } }); } } catch(e) { if (options &amp;&amp; options.error &amp;&amp; (typeof options.error === &quot;function&quot;)) { options.error(e); } //throw(e); } } else { logger.warn(&quot;no datasource&quot;); } return {}; }, /** * @method fetch Fetch the entity * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ fetch: function(options) { this.sync(&quot;read&quot;, options); }, /** * @method save Save the entity * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ save: function(options) { this.sync(&quot;create&quot;, options); }, /** * @method update Update the entity * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ update: function(options) { this.sync(&quot;update&quot;, options); }, /** * @method destroy Destroy the entity * @param {object} options Any options to pass * @memberof Augmented.Service.Entity */ destroy: function(options) { this.sync(&quot;delete&quot;, options); } }); /** * Resource class to handle REST from Node&lt;/br/&gt; * &lt;em&gt;Note: URL property is required&lt;/em&gt; * * @constructor Augmented.Service.Resource * @extends Augmented.Model * @memberof Augmented.Service */ Augmented.Service.Resource = Augmented.Model.extend({ id: &quot;&quot;, /** * @property {string} url The url for the REST Service * @memberof Augmented.Service.Resource */ url: &quot;&quot;, /** * @method initialize Initialize the model with needed wiring * @param {object} options Any options to pass * @memberof Augmented.Service.Resource */ initialize: function(options) { //logger.log(&quot;initialize&quot;); if (options &amp;&amp; options.url) { this.url = options.url; } // don't save this as data, but properties via the object base class options copy. this.unset(&quot;url&quot;); this.init(options); }, /** * @method init Custom init method for the model (called at inititlize) * @param {object} options Any options to pass * @memberof Augmented.Service.Resource */ init: function(options) {}, /** * @method fetch Fetch the Resource * @param {object} options Any options to pass * @memberof Augmented.Service.Resource */ fetch: function(options) { this.sync(&quot;read&quot;, options); }, /** * @method sync Sync method to handle REST functions for the model * @param {string} method the operation to perform * @param {object} options Any options to pass * @memberof Augmented.Service.Resource */ sync: function(method, options) { logger.debug(&quot;sync &quot; + method); if (this.url) { var that = this, success, error; if (options &amp;&amp; options.success &amp;&amp; (typeof options.success === &quot;function&quot;)) { success = options.success; } if (options &amp;&amp; options.error &amp;&amp; (typeof options.error === &quot;function&quot;)) { error = options.error; } try { var j = {}, q, u = (typeof this.url === &quot;function&quot;) ? this.url() : this.url; if (method === &quot;create&quot;) { j = that.attributes; var options = { path: u, method: &quot;POST&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot;, } }; var req = http.request(options, function(res) { logger.debug(&quot;Status: &quot; + res.statusCode); logger.debug(&quot;Headers: &quot; + JSON.stringify(res.headers)); res.setEncoding(&quot;utf8&quot;); res.on(&quot;data&quot;, function (body) { logger.debug(&quot;Body: &quot; + body); }); res.once(&quot;end&quot;, function() { if (success) { success(req.statusCode); } }); }); req.on(&quot;error&quot;, function(e) { logger.error(&quot;problem with request: &quot; + e.message); if (error) { error(500, e); } }); // write data to request body req.write(that.toJSON()); req.end(); } else if (method === &quot;update&quot;) { j = that.attributes; var options = { path: u, method: &quot;PUT&quot;, headers: { &quot;Content-Type&quot;: &quot;application/json&quot;, } }; var req = http.request(options, function(res) { logger.debug(&quot;Status: &quot; + res.statusCode); logger.debug(&quot;Headers: &quot; + JSON.stringify(res.headers)); res.setEncoding(&quot;utf8&quot;); res.on(&quot;data&quot;, function (body) { logger.debug(&quot;Body: &quot; + body); }); res.once(&quot;end&quot;, function() { if (success) { success(req.statusCode, req.statusMessage); } }); }); req.on(&quot;error&quot;, function(e) { logger.error(&quot;problem with request: &quot; + e.message); if (error) { error(req.statusCode, e); } }); // write data to request body req.write(that.toJSON()); req.end(); } else if (method === &quot;delete&quot;) { var options = { path: u, method: &quot;DELETE&quot; }; var req = http.request(options, function(res) { logger.debug(&quot;Status: &quot; + res.statusCode); res.setEncoding(&quot;utf8&quot;); res.once(&quot;end&quot;, function() { if (success) { success(req.statusCode, req.statusMessage); } }); }); req.on(&quot;error&quot;, function(e) { logger.error(&quot;problem with request: &quot; + e.message); if (error) { error(500, e); } }); req.end(); } else { // read logger.debug(&quot;reading from &quot; + u); logger.debug(&quot;have options? &quot; + (options)); http.get(u, function(res) { var body = &quot;&quot;; // Will contain the final response // Received data is a buffer. // Adding it to our body res.on(&quot;data&quot;, function(data){ body += data; }); // After the response is completed, parse it and log it to the console if (res.statusCode &gt;= 200 &amp;&amp; res.statusCode &lt; 300) { res.once(&quot;end&quot;, function() { logger.debug(&quot;Got data: &quot; + body); var parsed = {}; try { parsed = JSON.parse(body); that.set(parsed); if (success) { success(res.statusCode, res.statusMessage); } } catch(e) { logger.error(&quot;Not JSON response, can't add to resource. Exception: &quot; + e); if (error) { error(res.statusCode, e); } } }); } else { logger.error(&quot;Unsuccessfull Fetch - &quot; + res.statusCode + &quot; &quot; + res.statusMessage); if (error) { error(res.statusCode, res.statusMessage); } } }) // If any error has occured, log error to console .once(&quot;error&quot;, function(e, options) { logger.error(&quot;Got error: &quot; + e.message); if (error) { error(500, e); } }); } } catch(e) { logger.error(&quot;Got exception: &quot; + e); if (error) { error(500, e); } } } else { logger.warn(&quot;no url&quot;); } return {}; } }); return Augmented.Service; })); × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Modules Classes Entity EntityCollection Logger MongoDataSource Resource ResourceCollection SOLRDataSource Namespaces Service DataSourceFactory × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Classes Classes Entity EntityCollection Logger MongoDataSource Resource ResourceCollection SOLRDataSource Namespaces Service DataSourceFactory × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Namespaces Classes Entity EntityCollection Logger MongoDataSource Resource ResourceCollection SOLRDataSource Namespaces Service DataSourceFactory × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"interfaces.list.html":{"id":"interfaces.list.html","title":"Interfaces","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Interfaces Classes Entity EntityCollection Logger MongoDataSource Resource ResourceCollection SOLRDataSource Namespaces Service DataSourceFactory × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Augmented.js Service ModuleThe Augmented.js Framework.Version 1.3.x&quot;Typhoon&quot;aug·ment·ed/ˌôɡˈmentəd /adjectiveadjective: augmented 1. having been made greater in size or value.ServiceThe Service extension. This extension adds: ORM style Entities and Collections REST Resource class and Collections Abstract Datasource interface MongoDB SOLR (work in progress) × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.module_Service.html":{"id":"Augmented.module_Service.html","title":"Module: Service","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Module: Service service.js - The Service Core ComponentThe Service extension adds extensive abilities to the service (Node.js) layer.This extension adds: DataSourceEntityResource Version: 1.3.2 Author: Bob Warren License: Apache-2.0 Source: service.js, line 1 Requires module:augmentedjs module:node module:http × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.html":{"id":"Augmented.Service.html","title":"Namespace: Service","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Namespace: Service Service The base namespece for all of the Service module. Source: service.js, line 35 Classes Entity EntityCollection Logger MongoDataSource Resource ResourceCollection SOLRDataSource Namespaces DataSourceFactory Members &lt;static, constant&gt; VERSION The standard version property Source: service.js, line 42 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.DataSource.html":{"id":"Augmented.Service.DataSource.html","title":"Interface: DataSource","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Interface: DataSource .Service. DataSource The datasource object for use as an interface for a datasource Source: service.js, line 107 Members &lt;static&gt; this.client Properties: Name Type Description client object The client for use in the DataSource Source: service.js, line 120 &lt;static&gt; this.collection Properties: Name Type Description collection object The collection for use in the DataSource Source: service.js, line 135 &lt;static&gt; this.db Properties: Name Type Description db object The database (or simular) for the datasource (if applicable) Source: service.js, line 130 &lt;static&gt; this.url Properties: Name Type Description url string The url for the datasource (if applicable) Source: service.js, line 125 Methods &lt;static&gt; closeConnection Close a connection to the DataSource () Source: service.js, line 142 Returns: Returns true if a connection is established Type boolean &lt;static&gt; getCollection Get the collection() Source: service.js, line 175 Returns: Returns the collection Type object &lt;static&gt; getConnection Get a connection to the DataSource() Source: service.js, line 136 Returns: Returns true if a connection is established Type boolean &lt;static&gt; insert Insert data(data) Parameters: Name Type Description data object Data to insert Source: service.js, line 148 &lt;static&gt; query Query data(query, callback) Parameters: Name Type Description query object The query object callback function A callback to execute during the query Source: service.js, line 166 Returns: Returns a value from the query or response code Type object &lt;static&gt; remove Remove data(data) Parameters: Name Type Description data object Data to remove Source: service.js, line 154 &lt;static&gt; setCollection Set the collection by name(name) Parameters: Name Type Description name string The name of the collection Source: service.js, line 184 &lt;static&gt; update Update data(data) Parameters: Name Type Description data object Data to update Source: service.js, line 160 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.DataSourceFactory.html":{"id":"Augmented.Service.DataSourceFactory.html","title":"Namespace: DataSourceFactory","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Namespace: DataSourceFactory .Service. DataSourceFactory The datasource factory to return an instance of a datasource configured by type Source: service.js, line 478 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.Entity.html":{"id":"Augmented.Service.Entity.html","title":"Class: Entity","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: Entity .Service. Entity new Entity() Entity class to handle ORM to a datasourceNote: Datasource property is required Source: service.js, line 723 Extends Augmented.Model Members &lt;static&gt; collection Properties: Name Type Description collection string The collection for the datasource (if applicable) Source: service.js, line 748 &lt;static&gt; datasource Properties: Name Type Description datasource Augmented.Service.DataSource Datasource instance Source: service.js, line 793 &lt;static&gt; url Properties: Name Type Description url string | function The url for the datasource (if applicable) Source: service.js, line 743 Methods &lt;static&gt; destroy Destroy the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 914 &lt;static&gt; fetch Fetch the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 890 &lt;static&gt; init Custom init method for the model (options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 783 &lt;static&gt; initialize Initialize the model with needed wireing(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 749 &lt;static&gt; save Save the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 898 &lt;static&gt; sync Sync method to handle datasource functions for the model(method, options) Parameters: Name Type Description method string the operation to perform options object Any options to pass Source: service.js, line 794 &lt;static&gt; update Update the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 906 &lt;static&gt; {any} query The query string to use for selection() The query to use for the query - defaults to &quot;id&quot; selection Source: service.js, line 733 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.EntityCollection.html":{"id":"Augmented.Service.EntityCollection.html","title":"Class: EntityCollection","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: EntityCollection .Service. EntityCollection new EntityCollection() Collection class to handle ORM to a datasourceNote: Datasource property is required Source: service.js, line 530 Members &lt;static&gt; datasource Properties: Name Type Description datasource Augmented.Service.DataSource Datasource instance Source: service.js, line 596 &lt;static&gt; name Collection name for us in a datasource or an identifier Properties: Name Type Description name string The name of the collection Source: service.js, line 543 &lt;static&gt; url Properties: Name Type Description url string The url for the datasource (if applicable) Source: service.js, line 554 Methods &lt;static&gt; destroy Destroy the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 706 &lt;static&gt; fetch Fetch the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 682 &lt;static&gt; init Custom init method for the model (options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 586 &lt;static&gt; initialize Initialize the model with needed wireing(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 555 &lt;static&gt; save Save the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 690 &lt;static&gt; setDatasource Set the datasource for the Collection(datasource) Parameters: Name Type Description datasource object The datasource object Source: service.js, line 597 &lt;static&gt; sync Sync method to handle datasource functions for the Collection(method, options) Parameters: Name Type Description method string the operation to perform options object Any options to pass Source: service.js, line 605 &lt;static&gt; update Update the entity(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 698 &lt;static&gt; {any} query The query string to use for selection() The query to use for the query - defaults to &quot;id&quot; selection Source: service.js, line 544 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.Logger.html":{"id":"Augmented.Service.Logger.html","title":"Class: Logger","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: Logger .Service. Logger new Logger() A nice console logger with prefix for service messages Source: service.js, line 49 Methods &lt;static&gt; getServiceLogger(level, prefix) Get an instance class of the service color logger Parameters: Name Type Description level Augmented.Logger.Level The logger level prefix string Optional prefix for the logger message Source: service.js, line 81 &lt;static&gt; setPrefix(prefix) Set the prefix of the logger Parameters: Name Type Description prefix string The prefix for the logger message Source: service.js, line 57 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.MongoDataSource.html":{"id":"Augmented.Service.MongoDataSource.html","title":"Class: MongoDataSource","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: MongoDataSource .Service. MongoDataSource new MongoDataSource() The MongoDB datasource instance class Implements: Augmented.Service.DataSource Source: service.js, line 225 Extends Augmented.Service.DataSource × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.Resource.html":{"id":"Augmented.Service.Resource.html","title":"Class: Resource","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: Resource .Service. Resource new Resource() Resource class to handle REST from NodeNote: URL property is required Source: service.js, line 924 Extends Augmented.Model Members &lt;static&gt; url Properties: Name Type Description url string The url for the REST Service Source: service.js, line 938 Methods &lt;static&gt; fetch Fetch the Resource(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 959 &lt;static&gt; init Custom init method for the model (options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 953 &lt;static&gt; initialize Initialize the model with needed wiring(options) Parameters: Name Type Description options object Any options to pass Source: service.js, line 939 &lt;static&gt; sync Sync method to handle REST functions for the model(method, options) Parameters: Name Type Description method string the operation to perform options object Any options to pass Source: service.js, line 967 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.ResourceCollection.html":{"id":"Augmented.Service.ResourceCollection.html","title":"Class: ResourceCollection","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: ResourceCollection .Service. ResourceCollection new ResourceCollection() Collection class to handle REST Source: service.js, line 501 Members &lt;static&gt; name Collection name for us in a datasource or an identifier Properties: Name Type Description name string The name of the collection Source: service.js, line 513 &lt;static&gt; url Properties: Name Type Description url string The url for the datasource (if applicable) Source: service.js, line 518 Methods &lt;static&gt; setURL Set the url for the ResourceCollection(url) Parameters: Name Type Description url string | function The URL or a function to retun a URL object Source: service.js, line 519 × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "},"Augmented.Service.SOLRDataSource.html":{"id":"Augmented.Service.SOLRDataSource.html","title":"Class: SOLRDataSource","body":" Augmented.js Namespaces Augmented.ServiceAugmented.Service.DataSourceFactory Modules Augmented.Service Classes Augmented.Service.EntityAugmented.Service.EntityCollectionAugmented.Service.LoggerAugmented.Service.MongoDataSourceAugmented.Service.ResourceAugmented.Service.ResourceCollectionAugmented.Service.SOLRDataSource Interfaces Augmented.Service.DataSource Class: SOLRDataSource .Service. SOLRDataSource new SOLRDataSource() The SOLR datasource instance class Implements: Augmented.Service.DataSource Source: service.js, line 410 Extends Augmented.Service.DataSource × Search results Close Documentation generated by JSDoc 3.4.3 on Mon Feb 27th 2017 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
